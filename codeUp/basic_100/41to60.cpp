#include <iostream>
using namespace std;

int main () {

    // 1041 - 입력받은 문자의 다음 문자 출력하기.
    // char a;
    // scanf("%c",&a);
    // printf("%c", a+1);

    // 1042 - 정수 두개 입려받아 나눈 몫.
    // int a,b;
    // scanf("%d %d", &a,&b);
    // printf("%d", a/b);
    
    // 1044 - 입력 + 1 출력
    // long long int a;
    // scanf("%lld", &a);
    // printf("%lld", a+1);

    // 1045 - 두 수 입력받고 자동 계산
    // int a, b;
    // scanf("%d %d", &a, &b);
    // printf("%d\n", a+b);
    // printf("%d\n", a-b);
    // printf("%d\n", a*b);
    // printf("%d\n", a/b);
    // printf("%d\n", a%b);
    // printf("%.2f", (float)a/b);

    // 1046 - 세개입력 합 평균
    // long long int a,b,c;
    // scanf("%d %d %d", &a, &b, &c);
    // printf("%lld\n", a+b+c);
    // printf("%.1f", (float)(a+b+c)/3);
    // printf("%.1f", (a+b+c)/3.0);

    // 1047 - 입력된 정수에 * 2 해서 출력 (비트시프트 연산)
    // int a;
    // scanf("%d", &a);
    // printf("%d", a<<1);

    // 1048 - 비트 시프트 연산
    // int a,b;
    // scanf("%d %d", &a, &b);
    // printf("%d", a<<b);

    //1049 ~ 1052 - 두 정수 비교
    // int a,b;
    // scanf("%d %d", &a, &b);
    // printf("%d", a>b);

    // 1053 ~ 1058 - 논리연산
    // int a;
    // scanf("%d",&a);
    // printf("%d", !a);

    //XOR 
    // int a,b;
    // scanf("%d %d", &a, &b);
    // printf("%d", (a&&!b)||(b&&!a));
    // printf("%d", a^b);

    // // 서로 같을 때만 출력
    // int a,b;
    // scanf("%d %d", &a, &b);
    // printf("%d", !(a^b));

    // 0,0 일 때만 출력
    // int a,b;
    // scanf("%d %d", &a, &b);
    // printf("%d", !(a||b));

    // 1059 - 비트단위로 바꿔서 표현
    // int a;
    // scanf("%d", &a);
    // printf("%d", ~a);

    /*
        비트단위(bitwise) 연산자 ~(tilde, 틸드라고 읽는다.)를 붙이면 된다.
        ^:(circumflex 써컴플렉스, caret 캐럿)


        예를 들어 1(32비트 2진수로 표현하면 00000000 00000000 00000000 0000001) 이 입력되었을 때, 
        ~1은 -2(11111111 11111111 11111111 11111110) 가 된다.

        예시
        int a=1;
        printf("%d", ~a); //-2가 출력된다.

        양의 정수는 2진수 형태로 바뀌어 저장되고,
        음의 정수는 "2의 보수 표현"방법으로 저장된다.


        그리고, -1은 0에서 1을 더 빼고 32비트만 표시하는 형태로
        11111111 11111111 11111111 11111111
        로 저장된다.

        -2는? -1에서 1을 더 빼면 된다.
        11111111 11111111 11111111 11111110
        로 저장된다.


        그래서...

        int 형으로 선언된 변수에는 

        최소
        -2147483648 을 의미하는 
        10000000 00000000 00000000 00000000
        부터

        최대
        +2147483647 을 의미하는
        01111111 11111111 11111111 11111111
        로 저장될 수 있는 것이다.

        그렇다면...
        -2147483648
        10000000 00000000 00000000 00000000
        에서 1을 더 뺀다면?

        01111111 11111111 11111111 11111111
        이 된다. 즉 -2147483649 가 아닌 +2147483647이 되는 것이다.
        이러한 것을 오버플로우(overflow, 넘침)이라고 한다.

        한편, 이러한 내용을 간단히 표시하면
        정수 n이라고 할 때,
        ~n = -n - 1
        -n = ~n + 1 과 같은 관계로 표현된다.
        
     */

    // 1060 - 비트단위의 and 연산
    int a,b;
    scanf("%d %d", &a, &b);
    printf("%d", a&b);

    /*

        ** 비트단위(bitwise) 연산자 종류
        ~(bitwise not)
        &(bitwise and)
        |(bitwise or)
        ^(bitwise xor)
        <<(bitwise left shift)
        >>(bitwise right shift)

        예를 들어 3과 5가 입력되었을 때를 살펴보면
        3   : 00000000 00000000 00000000 0000011
        5   : 00000000 00000000 00000000 0000101
        3&5 : 00000000 00000000 00000000 0000001
        이 된다.


        한편,
        이러한 비트단위 and 연산은 두 비트열이 주어졌을 때,
        같은 부분만 1로 체크해 출력해주는 것과 같다.

        거꾸로, 어떤 비트열의 특정 부분만 모두 0으로도 만들 수 있는데
        192.168.0.31 : 11000000.10101000.00000000.00011111
        255.255.255.0 : 11111111.11111111.11111111.00000000
        두 개의 ip 주소를 & 연산하면

        192.168.0.0 : 110000000.10101000.0000000.00000000
        을 계산할 수 있다.

        실제로 이 계산은 네트워크에 연결되어있는 두 개의 컴퓨터가 데이터를 주고받기 위해
        같은 네트워크에 있는지? 아닌지? 판단하는데 사용된다.

        한편, 이러한 비트단위 연산은 빠른 계산이 필요한

        그래픽처리에서 마스크연산(특정 부분을 가리고 출력하는)에도 효과적으로 사용된다. 
    */


    return 0;
}